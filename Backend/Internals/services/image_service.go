package services

import (
	"context"
	"errors"
	"fmt"
	"image"
	"time"

	//"github.com/google/uuid"

	"github.com/JacobGeorgeMathew/MiniProject_Media_Authentication_Platform-/Backend/internals/models"
	"github.com/JacobGeorgeMathew/MiniProject_Media_Authentication_Platform-/Backend/internals/repository"
	"github.com/JacobGeorgeMathew/MiniProject_Media_Authentication_Platform-/Backend/internals/watermark/engine"
	"github.com/JacobGeorgeMathew/MiniProject_Media_Authentication_Platform-/Backend/internals/watermark/fingerprint"
	"github.com/JacobGeorgeMathew/MiniProject_Media_Authentication_Platform-/Backend/internals/watermark/payload"
)

type ImageService struct {
	repo     *repository.DB
	vectorDB *fingerprint.QdrantDB
}

func NewImageService(repo *repository.DB, vectorDB *fingerprint.QdrantDB) *ImageService {
	return &ImageService{
		repo:     repo,
		vectorDB: vectorDB,
	}
}

type EmbedRequest struct {
	Title         *string
	Description   *string
	MimeType      *string
	IsAIGenerated bool
	CapturedAt    *time.Time
}

type AuthResult struct {
	WatermarkValid bool

	ExtractedMetadata *models.ImageMetadata

	SimilarImages    []*models.ImageMetadata
	SimilarityScores []float32
}

// func UUIDToUint64(id uuid.UUID) uint64 {
// 	b := id[:]
// 	var result uint64
// 	for i := 0; i < 8; i++ { // Use first 8 bytes
// 		result = (result << 8) | uint64(b[i])
// 	}
// 	return result
// }

// func Uint64ToUUID(val uint64) uuid.UUID {
// 	var id uuid.UUID
// 	for i := 7; i >= 0; i-- { // Write back to first 8 bytes
// 		id[i] = byte(val & 0xff)
// 		val >>= 8
// 	}
// 	// Lower 8 bytes (indices 8-15) remain zero
// 	return id
// }

func (s *ImageService) EmbedWatermarkInImage(
	ctx context.Context,
	img image.Image,
	req EmbedRequest,
) (*image.YCbCr, []float64, error) {

	////////////////////////////////////////////////////////////
	// 1Ô∏è‚É£ Convert image to Y matrix (required for Identify)
	////////////////////////////////////////////////////////////

	coeff_matrices := make([]engine.Constants, 0)
	coeff_matrices = append(coeff_matrices, *engine.CreateConstant(2, 3))
	coeff_matrices = append(coeff_matrices, *engine.CreateConstant(3, 2))

	_, _, alreadyWatermarked := engine.Identify(img, coeff_matrices)

	if alreadyWatermarked {
		return nil, nil, errors.New("image is already watermarked")
	}

	////////////////////////////////////////////////////////////
	// 2Ô∏è‚É£ Calculate image properties
	////////////////////////////////////////////////////////////

	bounds := img.Bounds()
	width := bounds.Dx()
	height := bounds.Dy()

	widthPtr := &width
	heightPtr := &height

	////////////////////////////////////////////////////////////
	// 3Ô∏è‚É£ Prepare metadata struct (ID will be generated by DB)
	////////////////////////////////////////////////////////////

	meta := models.ImageMetadata{
		Title:         req.Title,
		Description:   req.Description,
		MimeType:      req.MimeType,
		WidthPx:       widthPtr,
		HeightPx:      heightPtr,
		IsAIGenerated: req.IsAIGenerated,
		CapturedAt:    req.CapturedAt,
	}

	////////////////////////////////////////////////////////////
	// 4Ô∏è‚É£ Insert metadata into PostgreSQL
	////////////////////////////////////////////////////////////

	// 4Ô∏è‚É£ Insert metadata ‚Äî now returns serial_id too
	imageUUID, serialID, err := s.repo.InsertImageMetadata(ctx, meta)
	if err != nil {
		return nil, nil, err
	}

	////////////////////////////////////////////////////////////
	// 5Ô∏è‚É£ Convert UUID ‚Üí uint64 (lower 64 bits)
	////////////////////////////////////////////////////////////

	//uuidBytes := imageUUID
	//uuidUint64 := UUIDToUint64(uuidBytes)

	////////////////////////////////////////////////////////////
	// 6Ô∏è‚É£ Build payload fields
	////////////////////////////////////////////////////////////

	// 5Ô∏è‚É£ Build payload using serial_id directly ‚Äî NO conversion needed
	payloadFields := payload.PayloadFields{
		Version:    1,
		IsAI:       req.IsAIGenerated,
		Reserved:   0,
		MetadataID: uint64(serialID), // ‚Üê clean, lossless
	}
	payloadBits, err := payload.PayloadGenerate(payloadFields)
	if err != nil {
		return nil, nil, err
	}

	////////////////////////////////////////////////////////////
	// 7Ô∏è‚É£ Embed watermark in frequency domain
	////////////////////////////////////////////////////////////

	watermarkedImg, success := engine.EmbedWatermark(img, payloadBits, coeff_matrices)
	if !success {
		return nil, nil, errors.New("failed to embed watermark")
	}

	////////////////////////////////////////////////////////////
	// 8Ô∏è‚É£ Generate fingerprint (1024-D vector)
	////////////////////////////////////////////////////////////

	fingerprint := fingerprint.Createfingerprint(watermarkedImg)

	////////////////////////////////////////////////////////////
	// 9Ô∏è‚É£ Store fingerprint in Qdrant
	////////////////////////////////////////////////////////////

	// (store fingerprint still uses imageUUID for Qdrant)
	err = s.vectorDB.StoreFingerprint(ctx, imageUUID, fingerprint)

	////////////////////////////////////////////////////////////
	// üîü Return result
	////////////////////////////////////////////////////////////

	return watermarkedImg, fingerprint, nil
}

func (s *ImageService) ImageAuth(
	ctx context.Context,
	img image.Image,
	k int, // number of similar images
) (*AuthResult, error) {

	result := &AuthResult{}

	////////////////////////////////////////////////////////////
	// 1Ô∏è‚É£ Identify watermark
	////////////////////////////////////////////////////////////

	coeff_matrices := make([]engine.Constants, 0)
	coeff_matrices = append(coeff_matrices, *engine.CreateConstant(2, 3))
	coeff_matrices = append(coeff_matrices, *engine.CreateConstant(3, 2))

	_, _, exists := engine.Identify(img, coeff_matrices)
	if !exists {
		return nil, errors.New("no watermark detected in image")
	}

	result.WatermarkValid = true

	////////////////////////////////////////////////////////////
	// 2Ô∏è‚É£ Extract watermark bits from all tiles
	////////////////////////////////////////////////////////////

	payloadCopies, ok := engine.ExtractWatermark(img, coeff_matrices)
	fmt.Println("Length : ", len(payloadCopies))
	if !ok {

		return nil, errors.New("failed to extract watermark")
	}

	////////////////////////////////////////////////////////////
	// 3Ô∏è‚É£ Verify payload (majority vote + CRC check)
	////////////////////////////////////////////////////////////

	fields, err := payload.PayloadVerify(payloadCopies)
	if err != nil {
		fmt.Println("Error in Payload Verify")
		return nil, err
	}

	////////////////////////////////////////////////////////////
	// 4Ô∏è‚É£ Convert uint64 ‚Üí UUID
	////////////////////////////////////////////////////////////

	// 4Ô∏è‚É£ fields.MetadataID is directly the serial_id ‚Äî no UUID conversion
	serialID := int64(fields.MetadataID)

	////////////////////////////////////////////////////////////
	// 5Ô∏è‚É£ Fetch metadata from PostgreSQL
	////////////////////////////////////////////////////////////

	// 5Ô∏è‚É£ Fetch by serial_id
	meta, err := s.repo.GetImageMetadataBySerialID(ctx, serialID)
	// if err != nil || meta == nil {
	//     return nil, errors.New("metadata not found for extracted watermark ID")
	// }
	if err != nil {
		fmt.Println("Error in Postgres 1")
		return nil, err
	}
	if meta == nil {
		println("Error in metadata ")
		return nil, errors.New("metadata not found for extracted watermark ID")
	}

	// result.ExtractedMetadata = meta

	////////////////////////////////////////////////////////////
	// 6Ô∏è‚É£ Find similar images via Qdrant
	////////////////////////////////////////////////////////////

	similarIDs, scores, err := s.vectorDB.FindSimilar(ctx, img, k)
	if err != nil {
		return nil, err
	}

	////////////////////////////////////////////////////////////
	// 7Ô∏è‚É£ Fetch metadata batch for similar images
	////////////////////////////////////////////////////////////

	metaMap, err := s.repo.GetImageMetadataBatch(ctx, similarIDs)
	if err != nil {
		fmt.Println("Error in Postgres 2")
		return nil, err
	}

	var similarMetas []*models.ImageMetadata

	for _, id := range similarIDs {
		if m, ok := metaMap[id]; ok {
			similarMetas = append(similarMetas, m)
		}
	}

	result.SimilarImages = similarMetas
	result.SimilarityScores = scores

	return result, nil
}
